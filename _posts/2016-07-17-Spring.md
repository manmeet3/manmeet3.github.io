---
title: "Spring Framework Notes"
tags: [java, spring, eclipse, sts]
---

*This is just an ongoing piece of writing that serves as a summary of the things I am learning as I delve into the framework.*




### Lifecycle callbacks:
Init and destroy methods for a class can be defined 2 ways  
1. public class X implements InitializingBean, DisposableBean { }  
2. define in the bean config file:
{% highlight ruby %}
  <bean id ='X' class ='Y' initmethod = 'initmethod' destroy-method='dest-method'>
 {% endhighlight %}


### BeanPostProcessor:
Post creation processing for beans
This post processing runs for every bean in the config file
1. Create a class that implements the Beanprocessor class
2. Implement methods: public Object postProcessAfterInitialization
public Object postProcessBeforeInitialization 
3. Initialize the processor class by creating a new bean in the config file.

### Writing a BeanFactory Processor:
1. class X implements BeanFactoryPostProcessor which contains all of the methods that the post processing happens with. 
2. Declare this class in the bean file and it will be run each time.

*Properties files* → properties files can be added with .properties extension. You must then include org.springframework.beans.factory.config.PropertyPlaceholderConfigurer which automatically looks through the properties file and replaces it in place of the appropriate tags ie. ${pointA.pointX}

*Interfaces* → create an interfact class with method(s) that you want to use multiple times on similar objects. Implement this class in all of the other classes that it serves as an interface to. Create an object of the class you wish to use the interface with and type cast that to the interface class.
ie. Shape shape = (Shape) context.getBeat (“triangle”); for the class id triangle which shape is an interface to. 


### Annotations:

Can use annotations for required methods, but need to write a bean post processor which ensures that the annotations are enforced. 

@autowire annotation can be used to autowire. If only the annotation is put in place, then the config file is searched for a bean that matches the type with the argument into the function.

Furthermore, qualifiers can be used using the @Qualifier(“xxxx”) annotation and adding a 
{% highlight ruby %} <qualifier  value='xxxx'> {% endhighlight %} subtag.
*might need to add xml namespaces to the bean config if attributes such as qualifier are not picked up*

@Resource (name=”BEANID”) initializes the specific method with beanid as the arg. 
Be default the resource tag goes for the bean with the function variable argument name. 

JSR-250 annotations include: @PostConstruct, @PreDestroy perform self explanatory actions upon ben creation and destruction

@Component annotation above a class adds it to the bean config automatically. This results in a static behavior of the class. This is an advantage of using config file. 
Need to add the tag {% highlight ruby %} <context:component-scan base-package=””></context:component-scan> {% endhighlight %} to the config 


Resources:  
 [Spring in Action 4th ed.](https://www.amazon.com/Spring-Action-Craig-Walls/dp/161729120X/m "amazon")
[Youtube Video Tutorials](
https://www.youtube.com/playlist?list=PLC97BDEFDCDD169D7 "youtube")

